\documentclass[nodate]{../cs-classes/cs-classes}

\title{\textit{Report}\\Implementation of an Iterative Linear Quadratic Regulator (iLQR)}
\author{Gabriel Desfrene\and Antoine Groudiev}

\begin{document}
\begin{abstract}
    This report presents the Iterative Linear Quadratic Regulator (iLQR) approach to solve optimal control problems, and describes our implementation of this algorithm. We first introduce the problem of optimal control, the Linear Quadratic Regulator (LQR) algorithm used to solve it, and the extension provided by the iLQR algorithm. We then present our own implementation of the iLQR algorithm in \texttt{Rust}, and the \texttt{Python} bindings allowing its use alongside libraries such as \href{https://github.com/stack-of-tasks/pinocchio/}{Pinocchio}.
\end{abstract}

\section{Problem statement}
\subsection{General formulation}
The Iterative Linear Quadratic Regulator (iLQR) is a \emph{trajectory optimization} method for discrete, nonlinear, and finite-horizon optimal control problems. It is an extension of the Linear Quadratic Regulator (LQR) algorithm, which is used to solve optimal control problems for linear systems with quadratic cost functions.

Consider a discrete system described by a dynamics function:
\begin{equation*}
    x_{t+1} = f(x_t, u_t)
\end{equation*}
meaning that we can compute the state $x_{t+1}$ at time $t+1$ given the state $x_t$ at time $t$ and a control input $u_t$ at time $t$. Our goal is to find the sequence of controls $(u_t)$ that minimizes a given cost function; the iLQR method assumes that the cost function is quadratic, that is:
\begin{equation*}
    J = \frac{1}{2}(x_T-x^*)^\tp Q_f (x_T-x^*) + \sum_{t=0}^{T-1} x_t^\tp Q x_t + u_t^\tp R u_t
\end{equation*}
where $Q_f$ is the final state cost matrix, $Q$ the state cost matrix, and $R$ the control cost matrix, all of them being positive semi-definite.

\subsection{Example: the inverted pendulum}
Consider a simple pendulum, where we denote $x = (\theta, \dot{\theta})$ the state of the system, with $\theta$ the angle between the pendulum and the vertical axis, and $\dot{\theta}$ its angular velocity. The dynamics of the system are given by physical laws, and can be seen as a black-box function implemented in a simulator. We can use the following cost function to stabilize the pendulum in the upright position:
\begin{equation*}
    J = \frac{1}{2}\left(\theta^2+\dot{\theta}^2\right) + \frac{1}{2}\int_0^T ru^2 \dd
\end{equation*}
with $r=10^{-5}$. This corresponds to $Q_f = I_2$, $Q=O_2$, and $R=rI_1$. Such a cost function will penalize large angles and velocities, while minimizing the control effort (the integral term), with a weight $r$ to balance the two objectives.

\section{The iLQR algorithm}
\subsection{Overview}
The iLQR iteratively refines a trajectory $(x_t, u_t)$ by linearizing the dynamics around the current trajectory, and solving a sequence of LQR problems to find the optimal control inputs. The equation $x_{t+1} = f(x_t, u_t)$ is linearized as:
\begin{equation*}
    \delta x_{t+1} = A_t \delta x_t + B_t \delta u_t
\end{equation*}
where $A_t$ (resp. $B_t$) is the Jacobian of $f$ with respect to $x$ (resp. $u$) evaluated at $(x_t, u_t)$. In practice, such Jacobians can be provided by the simulator, or approximated using finite differences.

\subsection{Backward update}
\subsection{Forward update}
\section{Implementation}
We implemented the iLQR algorithm in \href{https://www.rust-lang.org/}{\texttt{Rust}}, a systems programming language known for its performance and safety guarantees. The core of the algorithm is implemented in \texttt{Rust}, while the \texttt{Python} bindings are generated with the help of the \href{https://pyo3.rs/v0.23.3/}{\texttt{pyo3}} library, allowing its use alongside Pinocchio, a \texttt{C++} library for rigid body dynamics. The code is available on GitHub: \href{https://github.com/Red-Rapious/iLQR}{\texttt{https://github.com/Red-Rapious/iLQR}}.

\section{Results}

\end{document}